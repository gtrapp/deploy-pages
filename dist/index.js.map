{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzLA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;AEDA;AACA;AACA;AACA","sources":["../webpack://deploy-pages/./src/context.js","../webpack://deploy-pages/./src/index.js","../webpack://deploy-pages/../../../../usr/local/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://deploy-pages/webpack/bootstrap","../webpack://deploy-pages/webpack/runtime/compat","../webpack://deploy-pages/webpack/before-startup","../webpack://deploy-pages/webpack/startup","../webpack://deploy-pages/webpack/after-startup"],"sourcesContent":["const core = require('@actions/core')\n\n// Load variables from Actions runtime\nconst getRequiredVars = () => {\n  return {\n    runTimeUrl: process.env.ACTIONS_RUNTIME_URL,\n    workflowRun: process.env.GITHUB_RUN_ID,\n    runTimeToken: process.env.ACTIONS_RUNTIME_TOKEN,\n    repositoryNwo: process.env.GITHUB_REPOSITORY,\n    buildVersion: process.env.GITHUB_SHA,\n    buildActor: process.env.GITHUB_ACTOR,\n    actionsId: process.env.GITHUB_ACTION,\n    githubToken: core.getInput('token')\n  }\n}\n\nmodule.exports = function getContext() {\n  const requiredVars = getRequiredVars()\n  for (const variable in requiredVars) {\n    if (requiredVars[variable] === undefined) {\n      throw new Error(`${variable} is undefined. Cannot continue.`)\n    }\n  }\n  core.debug('all variables are set')\n  return requiredVars\n}\n","require('regenerator-runtime/runtime')\n\n// This package assumes a site has already been built and the files exist in the current workspace\n// If there's an artifact named `artifact.tar`, it can upload that to actions on its own,\n// without the user having to do the tar process themselves.\n\nconst core = require('@actions/core')\n// const github = require('@actions/github'); // TODO: Not used until we publish API endpoint to the @action/github package\nconst axios = require('axios')\n\n// All variables we need from the runtime are loaded here\nconst getContext = require('./context')\n\n// TODO: If the artifact hasn't been created, we can create it and upload to artifact storage ourselves\n// const tar = require('tar')\nlet requestedDeployment = false\nclass Deployment {\n  constructor() {\n    const context = getContext()\n    this.runTimeUrl = context.runTimeUrl\n    this.repositoryNwo = context.repositoryNwo\n    this.runTimeToken = context.runTimeToken\n    this.buildVersion = context.buildVersion\n    this.buildActor = context.buildActor\n    this.actionsId = context.workflowRun\n    this.githubToken = context.githubToken\n    this.workflowRun = context.workflowRun\n  }\n\n  // Ask the runtime for the unsigned artifact URL and deploy to GitHub Pages\n  // by creating a deployment with that artifact\n  async create(idToken) {\n    try {\n      core.info(`Actor: ${this.buildActor}`)\n      core.info(`Action ID: ${this.actionsId}`)\n      const pagesDeployEndpoint = `https://api.github.com/repos/${this.repositoryNwo}/pages/deployment`\n      const artifactExgUrl = `${this.runTimeUrl}_apis/pipelines/workflows/${this.workflowRun}/artifacts?api-version=6.0-preview`\n      const statusUrl = `https://api.github.com/repos/${this.repositoryNwo}/pages/deployment/status/${process.env['GITHUB_SHA']}`\n      core.info(`Artifact URL: ${artifactExgUrl}`)\n\n\n      var cancelled = await axios.get(statusUrl, {\n        headers: {\n          Authorization: `token ${this.githubToken}`\n        }\n      })\n\n      if (cancelled.data.status == 'deployment_cancelled') {\n        throw new Error('Deployment cancelled. (Probably because of a newer run)')\n      }\n\n\n      const { data } = await axios.get(artifactExgUrl, {\n        headers: {\n          Authorization: `Bearer ${this.runTimeToken}`,\n          'Content-Type': 'application/json'\n        }\n      })\n      core.info(JSON.stringify(data))\n      if (data.value.length == 0) {\n        throw new Error('No uploaded artifact was found!')\n      }\n      const artifactUrl = `${data.value[0].url}&%24expand=SignedContent`\n      const payload = {\n        artifact_url: artifactUrl,\n        pages_build_version: this.buildVersion,\n        oidc_token: idToken\n      }\n      core.info(`Creating deployment with payload:\\n${JSON.stringify(payload, null, '\\t')}`)\n      const response = await axios.post(pagesDeployEndpoint, payload, {\n        headers: {\n          Accept: 'application/vnd.github.v3+json',\n          Authorization: `Bearer ${this.githubToken}`,\n          'Content-type': 'application/json'\n        }\n      })\n      requestedDeployment = true\n      core.info(`Created deployment for ${this.buildVersion}`)\n      core.info(JSON.stringify(response.data))\n    } catch (error) {\n      core.info(`Failed to create deployment for ${this.buildVersion}.`)\n      throw error\n    }\n  }\n\n  // Poll the deployment endpoint for status\n  async check() {\n    try {\n      const statusUrl = `https://api.github.com/repos/${this.repositoryNwo}/pages/deployment/status/${process.env['GITHUB_SHA']}`\n      const timeout = core.getInput('timeout')\n      const timeout_duration = core.getInput('timeout_duration')\n      const error_count_max = core.getInput('error_count')\n      var tries = 0\n      var error_count = 0\n      while (tries < timeout) {\n        tries++\n        await new Promise(r => setTimeout(r, timeout_duration))\n        var res = await axios.get(statusUrl, {\n          headers: {\n            Authorization: `token ${this.githubToken}`\n          }\n        })\n\n        if (res.data.status == 'succeed') {\n          core.info('Reported success!')\n          core.setOutput('status', 'succeed')\n          break\n        } else if (res.data.status == 'deployment_failed') {\n          // Fall into permanent error, it may be caused by ongoing incident or malicious deployment content or exhausted automatic retry times.\n          core.info('Deployment failed, try again later.')\n          core.setOutput('status', 'failed')\n          break\n        } else if (res.data.status == 'deployment_attempt_error') {\n          // A temporary error happened, a retry will be scheduled automatically.\n          core.info(\n            'Deployment temporarily failed, a retry will be automatically scheduled...'\n          )\n        } else if (res.data.status == 'deployment_cancelled') {\n          core.info('Deployment cancelled. (Probably from another run)')\n          core.setOutput('status', 'cancelled')\n          break\n        } else {\n          core.info('Current status: ' + res.data.status)\n        }\n\n        if (res.status != 200) {\n          error_count++\n        }\n\n        if (error_count >= error_count_max) {\n          core.info('Too many errors, aborting!')\n          core.setFailed('Failed with status code: ' + res.status)\n          break\n        }\n      }\n      if (tries >= timeout) {\n        core.info('Timeout reached, aborting!')\n        core.setFailed('Timeout reached, aborting!')\n      }\n    } catch (error) {\n      core.setFailed(error)\n    }\n  }\n}\n\nasync function cancelHandler(evtOrExitCodeOrError) {\n  try {\n    if (requestedDeployment) {\n      const pagesCancelDeployEndpoint = `https://api.github.com/repos/${process.env.GITHUB_REPOSITORY}/pages/deployment/cancel/${process.env.GITHUB_SHA}`\n      await axios.put(\n        pagesCancelDeployEndpoint,\n        {},\n        {\n          headers: {\n            Accept: 'application/vnd.github.v3+json',\n            Authorization: `Bearer ${process.env.GITHUB_TOKEN}`,\n            'Content-type': 'application/json'\n          }\n        }\n      )\n      core.info(`canceled ongoing deployment thru ${pagesCancelDeployEndpoint}`)\n    }\n  } catch (e) {\n    console.info('cancel deployment errored', e)\n  }\n  process.exit(isNaN(+evtOrExitCodeOrError) ? 1 : +evtOrExitCodeOrError)\n}\n\nasync function main() {\n  try {\n    const deployment = new Deployment()\n    const idToken = await core.getIDToken()\n    await deployment.create(idToken)\n    await deployment.check()\n  } catch (error) {\n    core.setFailed(error)\n  }\n}\n\nprocess.on('SIGINT', cancelHandler)\n\nprocess.on('SIGTERM', cancelHandler)\n\nmain()\n\nmodule.exports = { Deployment }\n",null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(96);\n",""],"names":[],"sourceRoot":""}